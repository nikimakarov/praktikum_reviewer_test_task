import datetime as dt
# Улучшение: В программе далее используются только методы now() и strptime(), можно ограничить набор import
# и оставить импорт только понадобившегося функционала модуля.


class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        self.date = (
            dt.datetime.now().date() if
            not
            date else dt.datetime.strptime(date, '%d.%m.%Y').date())
        # Улучшениe: Здесь следует поправить разбиение однострочной конструкции на более понятное: из-за того,
        # что она получилась громоздкой, лучше использовать стандартный if-else. По крайней мере, рекомендуем не
        # разделять if и not по разным строкам. Также данную условную конструкцию можно переписать без not.
        #
        # Улучшение: Вместо dt.datetime.now().date() более лаконичным вариантом будет использование
        # dt.date.today() - он будет делать то же, но сразу одним методом, вместо двух.
        #
        # Улучшение: '%d.%m.%Y' можно вынести как константу в атрибут класса. Строки, которые явно не
        # будут изменяться, как, например, строки с форматом, лучше всегда выносить в константу либо в атрибут
        # класса, либо в отдельный файл.
        self.comment = comment


class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    def add_record(self, record):
        self.records.append(record)

    def get_today_stats(self):
        today_stats = 0
        for Record in self.records:
            # Ошибка: необходимо переименовать имя переменной Record: оно уже есть в названии класса Record,
            # поэтому нужно использовать другое имя. Ошибка требований к коду: По стандарту PEP8 имя переменной
            # должно быть в нижнем регистре, то есть состоять из строчных букв.
            if Record.date == dt.datetime.now().date():
                # Улучшение: функция dt.datetime.now().date() вызывается несколько раз в разных местах программы,
                # а в данном цикле - каждую итерацию. Ее желательно вынести в отдельную глобальную переменную,
                # это поможет сократить количество лишних вызовов и улучшит эффективность программы. (Также вместо
                # нее лучше использовать dt.date.today(), как это писолось раннее).
                today_stats = today_stats + Record.amount
                # Сокращение кода: здесь можно использовать оператор сложения с присваиванием (+=),
                # чтобы упростить написание кода: today_stats += Record.amount.
        return today_stats

    def get_week_stats(self):
        week_stats = 0
        today = dt.datetime.now().date()
        for record in self.records:
            if (
                    (today - record.date).days < 7 and
                    (today - record.date).days >= 0
                    # Улучшение: здесь несколько условий можно объединить в одну конструкцию min <= val < max
                    # для читабельности: 0 <= (today - record.date).days < 7.
            ):
                week_stats += record.amount
        return week_stats


class CaloriesCalculator(Calculator):
    # Ошибка требований к коду: комментарий должен быть оформлен в соответствии с Docstring Conventions.
    #
    # Улучшение: в комментарии лучше описывать не только то, что функция получает, но и то, что она делает.
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        # Ошибка требований к коду: переменная x должна быть названа в соответствии со смыслом, по-английски,
        # не должно быть однобуквенных названий и транслита. Например, подойдет имя calories_remained - сколько калорий
        # осталось (по аналогии с cash_remained). Использование имен со смыслом в дальнейшем очень поможет при чтении
        # своего кода. Это также облегчит участь других разработчиков, которые в будущем будут читать код.
        x = self.limit - self.get_today_stats()
        if x > 0:
            return f'Сегодня можно съесть что-нибудь' \
                   f' ещё, но с общей калорийностью не более {x} кКал'
            # Ошибка требований к коду: Бэкслеши для переносов не применяются, вместо них выражение
            # можно заключить в круглые скобки.
        else:
            return ('Хватит есть!')
            # Улучшение: Скобки не нужны.


class CashCalculator(Calculator):
    # Улучшение: названия переменных выбраны отлично - это говорящие названия, поэтому комментарии к ним излишни.
    #
    # Другой вариант: вместо float(60) можно использовать строковый литерал 60.0. Так же и с float(70).
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.

    # Ошибка: get_today_cash_remained должен принимать только один аргумент помимо self - currency.
    # USD_RATE и EURO_RATE и так доступны в функции через self.
    def get_today_cash_remained(self, currency,
                                USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        currency_type = currency
        # Улучшение: currency_type = currency - здесь лучше инициализировать переменную дефолтным значением,
        # поскольку она никогда не будет равна currency. Здесь желательно подумать над более понятной логикой
        # в функции: например, использовать только переменную currency в сравнениях ниже, а currency_type
        # использовать только в качестве переменной для записи.
        cash_remained = self.limit - self.get_today_stats()
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            cash_remained == 1.00
            # Улучшение: в строке cash_remained == 1.00 вообще нет смысла в таком виде.
            # Возможно здесь опечатка и имелся ввиду оператор (/=) ? Даже в таком случае, подумайте,
            # будет ли работать код без этой строки?
            currency_type = 'руб'
        # Ошибка требований к коду: здесь два логических блока слились, нужна пустая строка между ними.
        if cash_remained > 0:
            return (
                f'На сегодня осталось {round(cash_remained, 2)} '
                f'{currency_type}'
            )
            # Ошибка требований к коду: В f-строках применяется только подстановка переменных и не должно быть
            # логических или арифметических операций, вызовов функций и подобной динамики. round() нужно
            # рассчитать заранее.
            #
            # Улучшение: Результат в скобках можно взять в тройные кавычки.
        elif cash_remained == 0:
            return 'Денег нет, держись'

        elif cash_remained < 0:
            # Ошибка требований к коду: последнее elif-условие здесь не имеет смысла, так как если выполнилось одно из
            # предыдущих условий, уже выполнился бы return.
            return 'Денег нет, держись:' \
                   ' твой долг - {0:.2f} {1}'.format(-cash_remained,
                                                     currency_type)
            # Ошибка требований к коду: Неконсистентное округление в первом и последнем условии: в одном используется
            # round(), в другом - format(). Для одинаковых задач нужно выбирать один способ решения.
            #
            # Ошибка требований к коду: Бэкслеши для переносов не применяются, вместо них выражение
            # можно заключить в круглые скобки.
            #
            # Улучшение: Аргументы функции форматирования лучше иметь на одной строке.

    def get_week_stats(self):
        # Ошибка: данный метод можно не переопределять в дочернем классе: в нем нет дополнительной логики.
        super().get_week_stats()
